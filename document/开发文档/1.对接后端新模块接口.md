# 对接后端新模块接口

本文档详细说明如何在前端项目中对接后端新增的业务模块接口，包括类型定义和 API 服务的开发流程。

我们以**商品管理模块（Product）**为例进行说明。

## 1. 创建类型定义（Types）

类型定义对应后端的 DTO、VO 和 Enums，按照包结构组织。

### 1.1 目录结构

```
src/services/type/
├── dto/
│   ├── common.ts          # 通用 DTO
│   ├── user.ts            # 用户相关 DTO
│   ├── system.ts          # 系统相关 DTO
│   └── product.ts         # 商品相关 DTO（新增）
├── vo/
│   ├── common.ts          # 通用 VO
│   ├── user.ts            # 用户相关 VO
│   ├── system.ts          # 系统相关 VO
│   └── product.ts         # 商品相关 VO（新增）
├── enums/
│   ├── common.ts          # 通用枚举
│   ├── user.ts            # 用户相关枚举
│   ├── system.ts          # 系统相关枚举
│   └── product.ts         # 商品相关枚举（新增）
├── http.ts                # HTTP 请求类型
└── index.ts               # 统一导出
```

### 1.2 创建 VO 文件

创建 `src/services/type/vo/product.ts`：

```typescript
import { ProductStatus } from '@/services'

/**
 * 商品 VO（对应后端 ProductVO）
 */
export interface ProductVO {
  id: number
  name: string
  description?: string
  price: number
  stock: number
  categoryId?: number
  categoryName?: string
  imageUrl?: string
  status: ProductStatus
  statusText?: string
  createTime: string
  updateTime: string
}
```

### 1.3 创建 DTO 文件

创建 `src/services/type/dto/product.ts`：

```typescript
import { BaseListDTO, ProductStatus } from '@/services'

/**
 * 添加商品 DTO（对应后端 AddProductDTO）
 */
export interface AddProductDTO {
  name: string
  description?: string
  price: number
  stock: number
  categoryId?: number
  imageUrl?: string
}

/**
 * 更新商品 DTO（对应后端 UpdateProductDTO）
 */
export interface UpdateProductDTO extends AddProductDTO {
  id: number
}

/**
 * 查询商品 DTO（对应后端 GetProductsDTO）
 */
export interface GetProductsDTO extends BaseListDTO {
  name?: string
  categoryId?: number
  status?: ProductStatus
  minPrice?: number
  maxPrice?: number
}
```

### 1.4 创建 Enums 文件

创建 `src/services/type/enums/product.ts`：

```typescript
/**
 * 商品状态枚举（对应后端枚举）
 */
export enum ProductStatus {
  OFF_SHELF = 0,  // 下架
  ON_SHELF = 1    // 上架
}

/**
 * 商品分类枚举（示例）
 */
export enum ProductCategory {
  ELECTRONICS = 1,    // 电子产品
  CLOTHING = 2,       // 服装鞋帽
  FOOD = 3           // 食品饮料
}
```

**类型定义规范：**
- VO 放在 `vo/` 目录，DTO 放在 `dto/` 目录，枚举放在 `enums/` 目录
- 接口名与后端 DTO/VO 保持一致
- 使用 `?` 标记可选字段（对应后端的非必填字段）
- 时间字段统一使用 `string` 类型
- 可以使用 `extends` 继承复用类型（如 `BaseListDTO`）
- 字段名使用小驼峰命名（与后端保持一致）
- 枚举值与后端保持一致

### 1.5 导出类型

在 `src/services/type/index.ts` 中统一导出：

```typescript
// 导出商品相关类型
export * from './vo/product'
export * from './dto/product'
export * from './enums/product'
```

## 2. 创建 API 服务（Services）

API 服务层负责封装所有后端接口调用。

### 2.1 创建 API 服务文件

创建 `src/services/api/product.ts`：

```typescript
import http from '../http'
import type { 
  ProductVO, 
  AddProductDTO, 
  UpdateProductDTO, 
  GetProductsDTO,
  PageQueryDTO,
  PageResponse
} from '@/services'

/**
 * 商品管理 API
 */
export const productApi = {
  /**
   * 添加商品
   * @param data 商品信息
   */
  addProduct(data: AddProductDTO) {
    return http.post<number>('/product/add', { data, showSuccess: true })
  },

  /**
   * 获取商品详情
   * @param id 商品ID
   */
  getProduct(id: number) {
    return http.get<ProductVO>('/product/get', { params: { id } })
  },

  /**
   * 分页查询商品列表
   * @param params 分页查询参数
   */
  getProducts(params: PageQueryDTO<GetProductsDTO>) {
    return http.post<PageResponse<ProductVO>>('/product/list', { data: params })
  },

  /**
   * 更新商品
   * @param data 商品信息
   */
  updateProduct(data: UpdateProductDTO) {
    return http.post<void>('/product/update', { data, showSuccess: true })
  },

  /**
   * 删除商品（批量）
   * @param ids 商品ID列表
   */
  deleteProducts(ids: number[]) {
    return http.post<void>('/product/delete', { data: ids, showSuccess: true })
  }
}
```

### 2.2 在 index.ts 中注册 API

在 `src/services/index.ts` 中导入并注册：

```typescript
import { authApi, roleApi, userApi, permissionBkApi, logApi, statisticApi, noticeApi } from './api/user'
import { fileApi, settingApi } from './api/system'
import { productApi } from './api/product'  // 导入商品 API

// 统一导出所有API
const api = {
  auth: authApi,
  user: userApi,
  role: roleApi,
  permission_bk: permissionBkApi,
  file: fileApi,
  setting: settingApi,
  log: logApi,
  statistic: statisticApi,
  notice: noticeApi,
  product: productApi  // 注册商品 API
}

export default api

// 导出所有类型定义
export * from './type'
```

**注册后，可以通过 `api.product.方法名()` 调用。**

**API 服务规范：**
- 使用对象形式组织 API（如 `productApi`）
- 方法名与后端接口功能对应
- 使用 TypeScript 泛型指定返回类型（使用 VO 类型）
- 添加 JSDoc 注释说明参数和返回值
- 使用 `showSuccess: true` 显示成功提示（增删改操作）
- 使用 `showError: false` 隐藏错误提示（特殊场景）

### 2.2 HTTP 方法使用规范

与后端保持一致：

| 场景 | HTTP 方法 | 参数传递方式 | 示例 |
|------|-----------|-------------|------|
| 简单查询 | GET | `params`（URL参数） | `http.get('/product/get', { params: { id } })` |
| 复杂查询 | POST | `data`（RequestBody） | `http.post('/product/list', { data: params })` |
| 增删改操作 | POST | `data`（RequestBody） | `http.post('/product/add', { data, showSuccess: true })` |

### 2.3 HTTP 配置选项

`http` 方法支持以下配置选项：

```typescript
interface BaseRequest {
  params?: any          // URL 参数（GET 请求）
  data?: any           // 请求体（POST/PUT/DELETE 请求）
  showSuccess?: boolean // 是否显示成功提示，默认 false
  showError?: boolean   // 是否显示错误提示，默认 true
}
```

**使用示例：**

```typescript
// 显示成功提示
http.post('/product/add', { data, showSuccess: true })

// 隐藏错误提示（如刷新 token 时）
http.get('/auth/refresh', { params: { refreshToken }, showError: false })

// 同时配置
http.post('/product/update', { data, showSuccess: true, showError: false })
```

### 2.4 异常处理说明

**HTTP 层已统一处理异常，无需在 API 服务中处理：**

1. **成功响应（code === 200）**
   - 自动返回 `data` 部分
   - 如果 `showSuccess: true`，显示成功提示

2. **未授权（code === 401）**
   - 自动尝试刷新 token
   - 刷新成功后重新发送原始请求
   - 刷新失败则跳转登录页

3. **权限不足（code === 403）**
   - 自动刷新权限列表
   - 显示权限不足提示

4. **其他错误**
   - 显示错误提示（除非 `showError: false`）
   - 返回 `Promise.reject`

**因此，API 服务只需关注业务逻辑，不需要 try-catch。**

### 2.5 导出 API 服务

**重要：** 必须在 `src/services/index.ts` 中注册 API，才能通过 `api.模块名` 调用。

参考上面 2.2 节的注册方式。

## 3. 使用 API 服务

### 3.1 在组件中直接使用

```vue
<script setup lang="ts">
import { ref } from 'vue'
import api from '@/services'
import type { ProductVO } from '@/services'

const productList = ref<ProductVO[]>([])
const loading = ref(false)

// 加载商品列表
const loadProducts = async () => {
  loading.value = true
  try {
    const res = await api.product.getProducts({
      pageNum: 1,
      pageSize: 10,
      data: { name: '测试' }
    })
    productList.value = res.records
  } finally {
    loading.value = false
  }
}

// 添加商品
const addProduct = async () => {
  await api.product.addProduct({
    name: '新商品',
    price: 99.99,
    stock: 100
  })
  // 成功提示已由 HTTP 层自动显示
  loadProducts() // 刷新列表
}
</script>
```

### 3.2 在 Store 中使用

如果需要全局状态管理，可以在 Store 中调用 API：

```typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import api from '@/services'
import type { ProductVO } from '@/services'

export const useProductStore = defineStore('product', () => {
  const productList = ref<ProductVO[]>([])
  
  const fetchProducts = async () => {
    const res = await api.product.getProducts({
      pageNum: 1,
      pageSize: 10
    })
    productList.value = res.records
  }
  
  return { productList, fetchProducts }
})
```

**注意：** 不是所有模块都需要 Store，简单的增删改查可以直接在组件中使用 API。

## 4. 开发检查清单

完成接口对接后，请检查：

- [ ] 创建了 VO 文件（`services/type/vo/product.ts`）
- [ ] 创建了 DTO 文件（`services/type/dto/product.ts`）
- [ ] 创建了 Enums 文件（`services/type/enums/product.ts`）
- [ ] 类型定义与后端 DTO/VO/Enums 保持一致
- [ ] 创建了 API 服务文件（`services/api/product.ts`）
- [ ] API 方法与后端接口一一对应
- [ ] 使用了正确的 HTTP 方法（GET/POST）
- [ ] 添加了 JSDoc 注释
- [ ] 配置了 `showSuccess` 选项（增删改操作）
- [ ] 在 `index.ts` 中导出了类型和 API

## 5. 下一步

接口对接完成后，可以：

1. **开发页面组件** - 参考《2.页面开发.md》
2. **添加状态管理** - 参考《3.状态管理.md》（可选）

---

**提示：** API 服务只负责接口调用，不处理业务逻辑和状态管理。保持职责单一，便于维护和测试。